<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1、数据库三范式是什么? | 小熊学Java</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="./xiaobear.ico">
    <meta name="description" content="放弃很容易，但坚持一定很酷！">
    
    <link rel="preload" href="/assets/css/0.styles.24e9ee78.css" as="style"><link rel="preload" href="/assets/js/app.3819fb42.js" as="script"><link rel="preload" href="/assets/js/7.11ff0c83.js" as="script"><link rel="preload" href="/assets/js/51.3151143d.js" as="script"><link rel="prefetch" href="/assets/js/10.2d192518.js"><link rel="prefetch" href="/assets/js/11.b5e89b5d.js"><link rel="prefetch" href="/assets/js/12.eed22536.js"><link rel="prefetch" href="/assets/js/13.5f923940.js"><link rel="prefetch" href="/assets/js/14.32f640b5.js"><link rel="prefetch" href="/assets/js/15.2a1593c2.js"><link rel="prefetch" href="/assets/js/16.50b46ca9.js"><link rel="prefetch" href="/assets/js/17.d189b9a3.js"><link rel="prefetch" href="/assets/js/18.d63b0885.js"><link rel="prefetch" href="/assets/js/19.06d577d6.js"><link rel="prefetch" href="/assets/js/2.713f1c34.js"><link rel="prefetch" href="/assets/js/20.c92a30d9.js"><link rel="prefetch" href="/assets/js/21.c1c264a0.js"><link rel="prefetch" href="/assets/js/22.98985c80.js"><link rel="prefetch" href="/assets/js/23.3db2bac6.js"><link rel="prefetch" href="/assets/js/24.dd4eb391.js"><link rel="prefetch" href="/assets/js/25.70dc732e.js"><link rel="prefetch" href="/assets/js/26.40c0c739.js"><link rel="prefetch" href="/assets/js/27.82eef90c.js"><link rel="prefetch" href="/assets/js/28.b08d6e4b.js"><link rel="prefetch" href="/assets/js/29.ff3a8ea9.js"><link rel="prefetch" href="/assets/js/3.2271424e.js"><link rel="prefetch" href="/assets/js/30.90a65882.js"><link rel="prefetch" href="/assets/js/31.0917577e.js"><link rel="prefetch" href="/assets/js/32.93db4a4f.js"><link rel="prefetch" href="/assets/js/33.2e6dd9de.js"><link rel="prefetch" href="/assets/js/34.9010d6bb.js"><link rel="prefetch" href="/assets/js/35.32b2db66.js"><link rel="prefetch" href="/assets/js/36.3924a846.js"><link rel="prefetch" href="/assets/js/37.28beb93c.js"><link rel="prefetch" href="/assets/js/38.41d648a1.js"><link rel="prefetch" href="/assets/js/39.f9a682ea.js"><link rel="prefetch" href="/assets/js/4.dc285a54.js"><link rel="prefetch" href="/assets/js/40.bd98deb6.js"><link rel="prefetch" href="/assets/js/41.b98ef386.js"><link rel="prefetch" href="/assets/js/42.f3915a24.js"><link rel="prefetch" href="/assets/js/43.0b4ee5bf.js"><link rel="prefetch" href="/assets/js/44.54626c06.js"><link rel="prefetch" href="/assets/js/45.97121788.js"><link rel="prefetch" href="/assets/js/46.7330782f.js"><link rel="prefetch" href="/assets/js/47.cae31f52.js"><link rel="prefetch" href="/assets/js/48.07a77b69.js"><link rel="prefetch" href="/assets/js/49.195107ef.js"><link rel="prefetch" href="/assets/js/5.b4be59bc.js"><link rel="prefetch" href="/assets/js/50.a1fa88d5.js"><link rel="prefetch" href="/assets/js/52.fd50cefc.js"><link rel="prefetch" href="/assets/js/53.1388d91f.js"><link rel="prefetch" href="/assets/js/54.7ca25299.js"><link rel="prefetch" href="/assets/js/55.93f8e41f.js"><link rel="prefetch" href="/assets/js/56.f7063ab6.js"><link rel="prefetch" href="/assets/js/57.d6845dd4.js"><link rel="prefetch" href="/assets/js/58.4e8e94d1.js"><link rel="prefetch" href="/assets/js/59.255d1a64.js"><link rel="prefetch" href="/assets/js/6.341424e0.js"><link rel="prefetch" href="/assets/js/60.58afd723.js"><link rel="prefetch" href="/assets/js/8.44ddeacf.js"><link rel="prefetch" href="/assets/js/9.5788d93d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.24e9ee78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小熊学Java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/brush/" class="nav-link">
  码不停题
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试专栏
</a></div><div class="nav-item"><a href="/install/" class="nav-link">
  安装教程
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习笔记
</a></div><div class="nav-item"><a href="/about/me.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/brush/" class="nav-link">
  码不停题
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试专栏
</a></div><div class="nav-item"><a href="/install/" class="nav-link">
  安装教程
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习笔记
</a></div><div class="nav-item"><a href="/about/me.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/javaBasics/overview.html" class="sidebar-link">Java概述</a></li><li><a href="/interview/javaBasics/objectOriented.html" class="sidebar-link">Java面向对象</a></li><li><a href="/interview/javaBasics/javaSE.html" class="sidebar-link">JavaSE</a></li><li><a href="/interview/javaBasics/typeOfData.html" class="sidebar-link">Java数据类型</a></li><li><a href="/interview/javaBasics/exception.html" class="sidebar-link">Java异常</a></li><li><a href="/interview/javaBasics/collection.html" class="sidebar-link">Java集合</a></li><li><a href="/interview/javaBasics/multithreading.html" class="sidebar-link">Java多线程</a></li><li><a href="/interview/javaBasics/io.html" class="sidebar-link">Java IO</a></li><li><a href="/interview/javaBasics/innerClass.html" class="sidebar-link">Java内部类</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java高级</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/javaHighLevel/reflection.html" class="sidebar-link">Java反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机基础</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/database/redis.html" class="sidebar-link">Redis</a></li><li><a href="/interview/database/MySQL.html" aria-current="page" class="active sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_1、数据库三范式是什么" class="sidebar-link">1、数据库三范式是什么?</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_2、请简述常用的索引有哪些种类" class="sidebar-link">2、请简述常用的索引有哪些种类?</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_3、mysql数据库中索引的工作机制是什么" class="sidebar-link">3、MySQL数据库中索引的工作机制是什么？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_4、mysql的基础操作命令" class="sidebar-link">4、MySQL的基础操作命令</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_5、一张表-里面有id自增主键-当insert了17条记录之后-删除了第15-16-17条记录-再把mysql重启-再insert一条记录-这条记录的id是18还是15" class="sidebar-link">5、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_6、mysql中varchar与char的区别以及varchar-32-中的32代表的涵义" class="sidebar-link">6、MySQL中varchar与char的区别以及varchar(32)中的32代表的涵义？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_7、select-和select-全部字段的2种写法有何优缺点" class="sidebar-link">7、SELECT * 和SELECT 全部字段的2种写法有何优缺点?</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_8、havng-子句-和-where的异同点" class="sidebar-link">8、HAVNG 子句 和 WHERE的异同点?</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_9、如何区分float和double" class="sidebar-link">9、如何区分FLOAT和DOUBLE？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_10、一张表最多创建多少索引" class="sidebar-link">10、一张表最多创建多少索引？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_11、mysql里记录金钱用什么字段类型" class="sidebar-link">11、MySQL里记录金钱用什么字段类型?</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_12、mysql-中有哪几种锁" class="sidebar-link">12、MySQL 中有哪几种锁？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_13、mysql-中有哪些不同的表格" class="sidebar-link">13、MySQL 中有哪些不同的表格？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_14、mysql如何优化distinct" class="sidebar-link">14、Mysql如何优化DISTINCT？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_15、char-和varchar-的区别" class="sidebar-link">15、CHAR 和VARCHAR 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_16、mysql-数据库作发布系统的存储-一天五万条以上的增量-预计运维三年-怎么优化" class="sidebar-link">16、MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_17、limit-1000000加载很慢的话-你是怎么解决的呢" class="sidebar-link">17、limit 1000000加载很慢的话，你是怎么解决的呢？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#方案二-在业务允许的情况下限制页数" class="sidebar-link">方案二：在业务允许的情况下限制页数：</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#方案三-order-by-索引-id为索引" class="sidebar-link">方案三：order by + 索引（id为索引）</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#方案四-利用延迟关联或者子查询优化超多分页场景。-先快速定位需要获取的id段-然后再关联" class="sidebar-link">方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_18、实践中如何优化-mysql" class="sidebar-link">18、实践中如何优化 MySQL？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_19、优化数据库的方法" class="sidebar-link">19、优化数据库的方法？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_20、innodb与myisam的区别" class="sidebar-link">20、InnoDB与MyISAM的区别</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_21、mysql遇到过死锁问题吗-你是如何解决的" class="sidebar-link">21、MySQL遇到过死锁问题吗，你是如何解决的？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_22、创建索引的原则" class="sidebar-link">22、创建索引的原则</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_23、创建索引的方式有哪些" class="sidebar-link">23、创建索引的方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_24、如何删除百万级别以上的数据" class="sidebar-link">24、如何删除百万级别以上的数据？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_25、索引的优缺点" class="sidebar-link">25、索引的优缺点？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_26、哪些情况适合创建索引" class="sidebar-link">26、哪些情况适合创建索引？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_1、字段的数值有唯一性的限制" class="sidebar-link">1、字段的数值有唯一性的限制</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_2、频繁作为where查询条件的字段" class="sidebar-link">2、频繁作为WHERE查询条件的字段</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_3、经常-group-by-和-order-by-的列" class="sidebar-link">3、经常 GROUP BY 和 ORDER BY 的列</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_4、update、delete-的-where-条件列" class="sidebar-link">4、UPDATE、DELETE 的 WHERE 条件列</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_5、distinct-字段需要创建索引" class="sidebar-link">5、DISTINCT 字段需要创建索引</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_6、多表-join-连接操作时-创建索引注意事项" class="sidebar-link">6、多表 JOIN 连接操作时，创建索引注意事项</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_7、使用列的类型小的创建索引" class="sidebar-link">7、使用列的类型小的创建索引</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_8、使用字符串前缀创建索引" class="sidebar-link">8、使用字符串前缀创建索引</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_9、-区分度高-散列性高-的列适合作为索引" class="sidebar-link">9、 区分度高(散列性高)的列适合作为索引</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_10、使用最频繁的列放到联合索引的左侧" class="sidebar-link">10、使用最频繁的列放到联合索引的左侧</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_11、在多个字段都要创建索引的情况下-联合索引优于单值索引" class="sidebar-link">11、在多个字段都要创建索引的情况下，联合索引优于单值索引</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_27、哪些情况下创建索引-但是没有生效" class="sidebar-link">27、哪些情况下创建索引，但是没有生效？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_28、数据库索引的原理-为什么要用b-树-为什么不用二叉树" class="sidebar-link">28、数据库索引的原理，为什么要用B+树，为什么不用二叉树？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_29、如何选择合适的分布式主键" class="sidebar-link">29、如何选择合适的分布式主键？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_30、在高并发情况下-如何做到安全的修改同一行数据" class="sidebar-link">30、在高并发情况下，如何做到安全的修改同一行数据？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#使用悲观锁" class="sidebar-link">使用悲观锁</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#使用乐观锁" class="sidebar-link">使用乐观锁</a></li></ul></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_31、数据库自增主键可能遇到什么问题" class="sidebar-link">31、数据库自增主键可能遇到什么问题</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_32、mvcc你了解吗" class="sidebar-link">32、MVCC你了解吗？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_33、说一下大表查询的优化方案" class="sidebar-link">33、说一下大表查询的优化方案</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_34、blob和text有什么区别" class="sidebar-link">34、Blob和text有什么区别？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_35、组合索引是什么-为什么需要注意组合索引中的顺序" class="sidebar-link">35、组合索引是什么？为什么需要注意组合索引中的顺序？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_36、为什么要使用视图-什么是视图" class="sidebar-link">36、为什么要使用视图？什么是视图？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_37、视图有哪些特点-哪些使用场景" class="sidebar-link">37、视图有哪些特点？哪些使用场景？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_38、视图的优点-缺点-讲一下" class="sidebar-link">38、视图的优点，缺点，讲一下？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_39、count-1-、count-与-count-列名-的区别" class="sidebar-link">39、count(1)、count(*) 与 count(列名) 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_40、什么是存储过程-有哪些优缺点" class="sidebar-link">40、什么是存储过程？有哪些优缺点？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_41、什么是触发器-触发器的使用场景有哪些" class="sidebar-link">41、什么是触发器？触发器的使用场景有哪些？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_42、mysql中都有哪些触发器" class="sidebar-link">42、MySQL中都有哪些触发器？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_43、drop、delete与truncate的区别" class="sidebar-link">43、drop、delete与truncate的区别</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_44、列值为null时-查询是否会用到索引" class="sidebar-link">44、列值为NULL时，查询是否会用到索引？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_45、如果要存储用户的密码散列-应该使用什么字段进行存储" class="sidebar-link">45、如果要存储用户的密码散列，应该使用什么字段进行存储？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_46、innodb的事务实现原理" class="sidebar-link">46、Innodb的事务实现原理？</a></li><li class="sidebar-sub-header"><a href="/interview/database/MySQL.html#_47、mysql中text数据类型的最大长度" class="sidebar-link">47、MySQL中TEXT数据类型的最大长度</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java开发框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/framework/Spring.html" class="sidebar-link">Spring</a></li><li><a href="/interview/framework/Spring MVC.html" class="sidebar-link">Spring MVC</a></li><li><a href="/interview/framework/Mybatis.html" class="sidebar-link">Mybatis</a></li><li><a href="/interview/framework/Spring Boot.html" class="sidebar-link">Spring Boot</a></li><li><a href="/interview/framework/Spring Cloud.html" class="sidebar-link">Spring Cloud</a></li><li><a href="/interview/framework/Spring Cloud Alibaba.html" class="sidebar-link">Spring Cloud Alibaba</a></li><li><a href="/interview/framework/RabbitMQ.html" class="sidebar-link">RabbitMQ</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1、数据库三范式是什么"><a href="#_1、数据库三范式是什么" class="header-anchor">#</a> 1、数据库三范式是什么?</h2> <blockquote><ul><li>第一范式（1NF）：字段具有原子性,不可再分。(所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分)</li> <li>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。</li> <li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 所以第三范式具有如下特征：
<ul><li>每一列只有一个值</li> <li>每一行都能区分。</li> <li>每一个表都不包含其他表已经包含的非主关键字信息。</li></ul></li></ul></blockquote> <h2 id="_2、请简述常用的索引有哪些种类"><a href="#_2、请简述常用的索引有哪些种类" class="header-anchor">#</a> 2、请简述常用的索引有哪些种类?</h2> <blockquote><p>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</p> <p>按照 <strong>物理实现</strong>方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。</p> <p>按照 <strong>作用字段个数</strong> 进行划分，分成单列索引和联合索引</p> <ul><li><strong>普通索引:</strong> 即针对数据库表创建索引</li> <li><strong>唯一索引</strong>: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值</li> <li><strong>主键索引</strong>: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</li> <li><strong>组合索引</strong>: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</li> <li><strong>全文索引</strong>：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</li> <li><strong>覆盖索引</strong>：查询列要被所建的索引覆盖，不必读取数据行</li></ul></blockquote> <h2 id="_3、mysql数据库中索引的工作机制是什么"><a href="#_3、mysql数据库中索引的工作机制是什么" class="header-anchor">#</a> 3、MySQL数据库中索引的工作机制是什么？</h2> <blockquote><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p> <p>索引的实现通常使用B树及其变种B+树</p></blockquote> <h2 id="_4、mysql的基础操作命令"><a href="#_4、mysql的基础操作命令" class="header-anchor">#</a> 4、MySQL的基础操作命令</h2> <blockquote><ul><li>MySQL 是否处于运行状态:
<ul><li>Debian 上运行命令 <code>service mysql status</code>，</li> <li>在RedHat 上运行命令 <code>service mysqld status</code></li></ul></li> <li>开启或停止 MySQL 服务
<ul><li>service mysqld start 开启服务</li> <li>service mysqld stop 停止服务</li></ul></li> <li>列出所有数据库:运行命令 show databases;</li> <li>切换到某个数据库并在上面工作:运行命令 use databasename; 进入名为 databasename 的数据库</li> <li>列出某个数据库内所有表: show tables;</li></ul></blockquote> <h2 id="_5、一张表-里面有id自增主键-当insert了17条记录之后-删除了第15-16-17条记录-再把mysql重启-再insert一条记录-这条记录的id是18还是15"><a href="#_5、一张表-里面有id自增主键-当insert了17条记录之后-删除了第15-16-17条记录-再把mysql重启-再insert一条记录-这条记录的id是18还是15" class="header-anchor">#</a> 5、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h2> <blockquote><ol><li>如果表的类型为<code>MyISAM</code>，ID为18
<ul><li>因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失</li></ul></li> <li>如果表的类型是<code>InnoDB</code>，ID是15
<ul><li>InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失</li></ul></li></ol></blockquote> <h2 id="_6、mysql中varchar与char的区别以及varchar-32-中的32代表的涵义"><a href="#_6、mysql中varchar与char的区别以及varchar-32-中的32代表的涵义" class="header-anchor">#</a> 6、MySQL中varchar与char的区别以及varchar(32)中的32代表的涵义？</h2> <blockquote><p><code>varchar</code>与<code>char</code>的区别:</p> <ul><li>char是一种固定长度的类型</li> <li>varchar则是一种可变长度的类型.</li></ul> <p><code>varchar(32)</code>中32的涵义 : 最多存放32个字节</p> <p>int（20）中20的涵义: int(M)中的M indicates the maximum display width (最大显示宽度)for integer types. The maximum legal display width is 255.</p></blockquote> <h2 id="_7、select-和select-全部字段的2种写法有何优缺点"><a href="#_7、select-和select-全部字段的2种写法有何优缺点" class="header-anchor">#</a> 7、<code>SELECT *</code> 和<code>SELECT 全部字段</code>的2种写法有何优缺点?</h2> <table><thead><tr><th></th> <th style="text-align:center;">SELECT *</th> <th style="text-align:center;">SELECT 全部字段</th></tr></thead> <tbody><tr><td>解析数据字典</td> <td style="text-align:center;">需要</td> <td style="text-align:center;">不需要</td></tr> <tr><td>输出顺序</td> <td style="text-align:center;">建表列顺序相同</td> <td style="text-align:center;">指定字段顺序</td></tr> <tr><td>字段改名</td> <td style="text-align:center;">不需要修改</td> <td style="text-align:center;">需要</td></tr> <tr><td>索引优化</td> <td style="text-align:center;">无法优化</td> <td style="text-align:center;">可以建立索引进行优化</td></tr> <tr><td>可读性</td> <td style="text-align:center;">可读性低</td> <td style="text-align:center;">可读性高</td></tr></tbody></table> <h2 id="_8、havng-子句-和-where的异同点"><a href="#_8、havng-子句-和-where的异同点" class="header-anchor">#</a> 8、HAVNG 子句 和 WHERE的异同点?</h2> <table><thead><tr><th></th> <th style="text-align:center;">having</th> <th style="text-align:center;">where</th></tr></thead> <tbody><tr><td>语法上</td> <td style="text-align:center;">having用select结果别名</td> <td style="text-align:center;">where 用表中列名</td></tr> <tr><td>结果范围</td> <td style="text-align:center;">返回客户端的行数</td> <td style="text-align:center;">where从表读出数据的行数</td></tr> <tr><td>索引</td> <td style="text-align:center;">不能使用索引，只能在临时结果集操作</td> <td style="text-align:center;">可以使用索引</td></tr> <tr><td>聚集函数</td> <td style="text-align:center;">专门使用聚集函数的</td> <td style="text-align:center;">不能使用聚集函数</td></tr></tbody></table> <h2 id="_9、如何区分float和double"><a href="#_9、如何区分float和double" class="header-anchor">#</a> 9、如何区分FLOAT和DOUBLE？</h2> <blockquote><ul><li>浮点数以8位精度存储在FLOAT中，并且有四个字节</li> <li>浮点数存储在DOUBLE中，精度为18位，有八个字节</li></ul></blockquote> <h2 id="_10、一张表最多创建多少索引"><a href="#_10、一张表最多创建多少索引" class="header-anchor">#</a> 10、一张表最多创建多少索引？</h2> <blockquote><p>任何标准表最多可以创建16个索引列。</p></blockquote> <h2 id="_11、mysql里记录金钱用什么字段类型"><a href="#_11、mysql里记录金钱用什么字段类型" class="header-anchor">#</a> 11、MySQL里记录金钱用什么字段类型?</h2> <blockquote><p><code>NUMERIC</code>和<code>DECIMAL</code>类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。</p></blockquote> <p>PS：<code>salary DECIMAL(9,2)</code></p> <p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。</p> <p>因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价</p> <p>于DECIMAL(p,0)。</p> <p>同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的</p> <p>任何一种。</p> <h2 id="_12、mysql-中有哪几种锁"><a href="#_12、mysql-中有哪几种锁" class="header-anchor">#</a> 12、MySQL 中有哪几种锁？</h2> <blockquote><p><code>表级锁</code>： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。
<code>行级锁</code>： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。
<code>页面锁</code>： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。</p></blockquote> <h2 id="_13、mysql-中有哪些不同的表格"><a href="#_13、mysql-中有哪些不同的表格" class="header-anchor">#</a> 13、MySQL 中有哪些不同的表格？</h2> <blockquote><ul><li>MyISAM</li> <li>Heap</li> <li>Merge</li> <li>INNODB</li> <li>MISAM</li></ul> <p>MyISAM是Mysql的默认存储引擎。</p></blockquote> <h2 id="_14、mysql如何优化distinct"><a href="#_14、mysql如何优化distinct" class="header-anchor">#</a> 14、Mysql如何优化DISTINCT？</h2> <blockquote><p>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</p></blockquote> <h2 id="_15、char-和varchar-的区别"><a href="#_15、char-和varchar-的区别" class="header-anchor">#</a> 15、CHAR 和VARCHAR 的区别？</h2> <blockquote><ul><li>CHAR 和 VARCHAR <strong>类型在存储和检索方面有所不同</strong></li> <li>CHAR 列长度固定为创建表时声明的长度， 长度值范围是 1 到 255 当 CHAR 值被存储时， 它们被用空格填充到特定长度， 检索 CHAR 值时需删除尾随空格。</li></ul></blockquote> <h2 id="_16、mysql-数据库作发布系统的存储-一天五万条以上的增量-预计运维三年-怎么优化"><a href="#_16、mysql-数据库作发布系统的存储-一天五万条以上的增量-预计运维三年-怎么优化" class="header-anchor">#</a> 16、MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？</h2> <blockquote><ul><li>设计良好的数据库结构， 允许部分数据冗余， 尽量避免 join 查询， 提高效率。</li> <li>选择合适的表字段数据类型和存储引擎， 适当的添加索引。</li> <li>MySQL 库主从读写分离。</li> <li>找规律分表， 减少单表中的数据量提高查询速度。</li> <li>添加缓存机制， 比如 memcached， apc等。</li> <li>不经常改动的页面， 生成静态页面。</li> <li>书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</li></ul></blockquote> <h2 id="_17、limit-1000000加载很慢的话-你是怎么解决的呢"><a href="#_17、limit-1000000加载很慢的话-你是怎么解决的呢" class="header-anchor">#</a> 17、limit 1000000加载很慢的话，你是怎么解决的呢？</h2> <blockquote><p><strong>方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>select id，name from employee where id&gt;1000000 limit 10.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="方案二-在业务允许的情况下限制页数"><a href="#方案二-在业务允许的情况下限制页数" class="header-anchor">#</a> <strong>方案二：在业务允许的情况下限制页数：</strong></h3> <p>建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</p> <h3 id="方案三-order-by-索引-id为索引"><a href="#方案三-order-by-索引-id为索引" class="header-anchor">#</a> <strong>方案三：order by + 索引（id为索引）</strong></h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>select id，name from employee order by id  limit 1000000，10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="方案四-利用延迟关联或者子查询优化超多分页场景。-先快速定位需要获取的id段-然后再关联"><a href="#方案四-利用延迟关联或者子查询优化超多分页场景。-先快速定位需要获取的id段-然后再关联" class="header-anchor">#</a> <strong>方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</strong></h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <h2 id="_18、实践中如何优化-mysql"><a href="#_18、实践中如何优化-mysql" class="header-anchor">#</a> 18、实践中如何优化 MySQL？</h2> <blockquote><ul><li>SQL 语句及索引的优化</li> <li>数据库表结构的优化</li> <li>系统配置的优化</li> <li>硬件的优化</li></ul></blockquote> <h2 id="_19、优化数据库的方法"><a href="#_19、优化数据库的方法" class="header-anchor">#</a> 19、优化数据库的方法？</h2> <blockquote><ul><li>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’ 省份’、’ 性别’ 最好适用 ENUM</li> <li>使用连接(JOIN)来代替子查询</li> <li>适用联合(UNION)来代替手动创建的临时表</li> <li>事务处理</li> <li>分库分表</li> <li>读写分离</li> <li>锁定表、优化事务处理</li> <li>适用外键， 优化锁定表</li> <li>建立索引</li> <li>优化查询语句</li></ul></blockquote> <h2 id="_20、innodb与myisam的区别"><a href="#_20、innodb与myisam的区别" class="header-anchor">#</a> 20、InnoDB与MyISAM的区别</h2> <blockquote><ul><li>InnoDB支持事务，MyISAM不支持事务</li> <li>InnoDB支持外键，MyISAM不支持外键</li> <li>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</li> <li>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li> <li>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li> <li>InnoDB支持表、行级锁，而MyISAM支持表级锁。</li> <li>InnoDB表必须有主键，而MyISAM可以没有主键</li> <li>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li> <li>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li> <li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li></ul></blockquote> <h2 id="_21、mysql遇到过死锁问题吗-你是如何解决的"><a href="#_21、mysql遇到过死锁问题吗-你是如何解决的" class="header-anchor">#</a> 21、MySQL遇到过死锁问题吗，你是如何解决的？</h2> <blockquote><ul><li>查看死锁日志show engine innodb status;</li> <li>找出死锁Sql</li> <li>分析sql加锁情况</li> <li>模拟死锁案发</li> <li>分析死锁日志</li> <li>分析死锁结果</li></ul></blockquote> <h2 id="_22、创建索引的原则"><a href="#_22、创建索引的原则" class="header-anchor">#</a> 22、创建索引的原则</h2> <blockquote><ul><li>最左前缀匹配原则</li> <li>频繁作为查询条件的字段才去创建索引</li> <li>频繁更新的字段不适合创建索引</li> <li>索引列不能参与计算，不能有函数操作</li> <li>优先考虑扩展索引，而不是新建索引，避免不必要的索引</li> <li>在order by或者group by子句中，创建索引需要注意顺序</li> <li>区分度低的数据列不适合做索引列(如性别）</li> <li>定义有外键的数据列一定要建立索引。</li> <li>对于定义为text、image数据类型的列不要建立索引。</li> <li>删除不再使用或者很少使用的索引</li></ul></blockquote> <h2 id="_23、创建索引的方式有哪些"><a href="#_23、创建索引的方式有哪些" class="header-anchor">#</a> 23、创建索引的方式有哪些？</h2> <blockquote><ol><li><p>在创建表的时候创建索引</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name <span class="token punctuation">[</span>col_name data_type<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT <span class="token operator">|</span> SPATIAL<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">KEY</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>index_name<span class="token punctuation">]</span> <span class="token punctuation">(</span>col_name <span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</p></li> <li><p>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</p></li> <li><p>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p></li> <li><p>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p></li> <li><p>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p></li> <li><p>ASC 或 DESC 指定升序或者降序的索引值存储。</p></li></ul></li> <li><p>使用ALTER TABLE命令添加索引</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">index</span> index_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>使用CREATE INDEX命令创建</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> index_name <span class="token keyword">ON</span> table_name<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></blockquote> <h2 id="_24、如何删除百万级别以上的数据"><a href="#_24、如何删除百万级别以上的数据" class="header-anchor">#</a> 24、如何删除百万级别以上的数据？</h2> <blockquote><ul><li>可以删除百万数据的时候可以先删除索引</li> <li>然后批量删除其中无用数据</li> <li>删除完成后重新创建索引</li></ul></blockquote> <h2 id="_25、索引的优缺点"><a href="#_25、索引的优缺点" class="header-anchor">#</a> 25、索引的优缺点？</h2> <blockquote><p><strong>优点：</strong></p> <ul><li>类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因</li> <li>通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性</li> <li>在实现数据的参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度</li> <li>在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗</li></ul> <p><strong>缺点：</strong></p> <ul><li>创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加</li> <li>索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸</li> <li>虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度</li></ul></blockquote> <h2 id="_26、哪些情况适合创建索引"><a href="#_26、哪些情况适合创建索引" class="header-anchor">#</a> 26、哪些情况适合创建索引？</h2> <h3 id="_1、字段的数值有唯一性的限制"><a href="#_1、字段的数值有唯一性的限制" class="header-anchor">#</a> 1、字段的数值有唯一性的限制</h3> <blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p> <p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote> <h3 id="_2、频繁作为where查询条件的字段"><a href="#_2、频繁作为where查询条件的字段" class="header-anchor">#</a> 2、频繁作为WHERE查询条件的字段</h3> <blockquote><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p> <p>例如：比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p></blockquote> <h3 id="_3、经常-group-by-和-order-by-的列"><a href="#_3、经常-group-by-和-order-by-的列" class="header-anchor">#</a> 3、经常 GROUP BY 和 ORDER BY 的列</h3> <blockquote><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 <code>GROUP BY</code>对数据进行分组查询，或者使用<code>ORDER BY</code> 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code></p></blockquote> <h3 id="_4、update、delete-的-where-条件列"><a href="#_4、update、delete-的-where-条件列" class="header-anchor">#</a> 4、UPDATE、DELETE 的 WHERE 条件列</h3> <blockquote><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p></blockquote> <h3 id="_5、distinct-字段需要创建索引"><a href="#_5、distinct-字段需要创建索引" class="header-anchor">#</a> 5、DISTINCT 字段需要创建索引</h3> <blockquote><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率</p></blockquote> <h3 id="_6、多表-join-连接操作时-创建索引注意事项"><a href="#_6、多表-join-连接操作时-创建索引注意事项" class="header-anchor">#</a> 6、多表 JOIN 连接操作时，创建索引注意事项</h3> <blockquote><ol><li>连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li> <li>对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li> <li>对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型</li></ol></blockquote> <h3 id="_7、使用列的类型小的创建索引"><a href="#_7、使用列的类型小的创建索引" class="header-anchor">#</a> 7、使用列的类型小的创建索引</h3> <h3 id="_8、使用字符串前缀创建索引"><a href="#_8、使用字符串前缀创建索引" class="header-anchor">#</a> 8、使用字符串前缀创建索引</h3> <p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> shop<span class="token punctuation">(</span>address <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">alter</span> <span class="token keyword">table</span> shop <span class="token keyword">add</span> <span class="token keyword">index</span><span class="token punctuation">(</span>address<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。<strong>怎么计算不同的长度的选择性呢？</strong></p> <p>先看一下字段在全部数据中的选择度：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> address<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> shop<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过不同长度去计算，与全表的选择性对比：</p> <p><strong>公式</strong>：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>列名<span class="token punctuation">,</span> 索引长度<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>例如：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub10<span class="token punctuation">,</span> <span class="token comment">-- 截取前10个字符的选择度 </span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub11<span class="token punctuation">,</span> <span class="token comment">-- 截取前15个字符的选择度 </span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub12<span class="token punctuation">,</span> <span class="token comment">-- 截取前20个字符的选择度 </span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sub13 <span class="token comment">-- 截取前25个字符的选择度</span>
<span class="token keyword">from</span> shop<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p> <p><strong>拓展：Alibaba《Java开发手册》</strong></p> <p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p> <p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p> <h3 id="_9、-区分度高-散列性高-的列适合作为索引"><a href="#_9、-区分度高-散列性高-的列适合作为索引" class="header-anchor">#</a> 9、 区分度高(散列性高)的列适合作为索引</h3> <h3 id="_10、使用最频繁的列放到联合索引的左侧"><a href="#_10、使用最频繁的列放到联合索引的左侧" class="header-anchor">#</a> 10、使用最频繁的列放到联合索引的左侧</h3> <blockquote><p>这样也可以较少的建立一些索引。同时，由于&quot;最左前缀原则&quot;，可以增加联合索引的使用率。</p></blockquote> <h3 id="_11、在多个字段都要创建索引的情况下-联合索引优于单值索引"><a href="#_11、在多个字段都要创建索引的情况下-联合索引优于单值索引" class="header-anchor">#</a> 11、在多个字段都要创建索引的情况下，联合索引优于单值索引</h3> <h2 id="_27、哪些情况下创建索引-但是没有生效"><a href="#_27、哪些情况下创建索引-但是没有生效" class="header-anchor">#</a> 27、哪些情况下创建索引，但是没有生效？</h2> <blockquote><ol><li>查询条件包含or，可能导致索引失效</li> <li>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</li> <li>like通配符可能导致索引失效。</li> <li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li> <li>在索引列上使用mysql的内置函数，索引失效。</li> <li>对索引列运算（如，+、-、*、/），索引失效。</li> <li>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li> <li>索引字段上使用is null， is not null，可能导致索引失效。</li> <li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li> <li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ol></blockquote> <h2 id="_28、数据库索引的原理-为什么要用b-树-为什么不用二叉树"><a href="#_28、数据库索引的原理-为什么要用b-树-为什么不用二叉树" class="header-anchor">#</a> 28、数据库索引的原理，为什么要用B+树，为什么不用二叉树？</h2> <blockquote><p><strong>为什么不是一般二叉树？</strong></p> <p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p> <p><strong>为什么不是平衡二叉树呢？</strong></p> <p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p> <p><strong>那为什么不是B树而是B+树呢？</strong></p> <ul><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p></li> <li><p>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p></li></ul></blockquote> <h2 id="_29、如何选择合适的分布式主键"><a href="#_29、如何选择合适的分布式主键" class="header-anchor">#</a> 29、如何选择合适的分布式主键？</h2> <blockquote><ul><li>数据库自增长序列或字段</li> <li>UUID</li> <li>Redis生成ID</li> <li>Twitter的snowflake算法</li> <li>利用zookeeper生成唯一ID</li> <li>MongoDB的ObjectId</li></ul></blockquote> <h2 id="_30、在高并发情况下-如何做到安全的修改同一行数据"><a href="#_30、在高并发情况下-如何做到安全的修改同一行数据" class="header-anchor">#</a> 30、在高并发情况下，如何做到安全的修改同一行数据？</h2> <blockquote><p>这种情况下，采用加锁的方式进行安全修改</p> <h3 id="使用悲观锁"><a href="#使用悲观锁" class="header-anchor">#</a> <strong>使用悲观锁</strong></h3> <p>悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>select * from User where name=‘jay’ for update
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上这条sql语句会锁定了User表中所有符合检索条件（name=‘jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。</p> <h3 id="使用乐观锁"><a href="#使用乐观锁" class="header-anchor">#</a> <strong>使用乐观锁</strong></h3> <p>乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote> <h2 id="_31、数据库自增主键可能遇到什么问题"><a href="#_31、数据库自增主键可能遇到什么问题" class="header-anchor">#</a> 31、数据库自增主键可能遇到什么问题</h2> <blockquote><ul><li>使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID解决，复杂的可以考虑前面提到的分布式主键方案</li> <li>自增主键会产生表锁，从而引发问题</li> <li>自增主键可能用完问题。</li></ul></blockquote> <h2 id="_32、mvcc你了解吗"><a href="#_32、mvcc你了解吗" class="header-anchor">#</a> 32、MVCC你了解吗？</h2> <blockquote><p><strong>多版本并发控制</strong>技术的英文全称是 <strong>Multiversion Concurrency Control</strong>，简称 <strong>MVCC</strong>。</p> <p><strong>多版本并发控制（MVCC）</strong> 是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p> <p>简单来说，<strong>多版本并发控制</strong> 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p> <p><strong>MVCC需要关注这几个知识点：</strong></p> <ul><li>事务版本号</li> <li>表的隐藏列</li> <li>undo log</li> <li>read view</li></ul></blockquote> <h2 id="_33、说一下大表查询的优化方案"><a href="#_33、说一下大表查询的优化方案" class="header-anchor">#</a> 33、说一下大表查询的优化方案</h2> <blockquote><ul><li>优化shema、sql语句+索引；</li> <li>可以考虑加缓存，memcached, redis，或者JVM本地缓存；</li> <li>主从复制，读写分离；</li> <li>分库分表；</li></ul></blockquote> <h2 id="_34、blob和text有什么区别"><a href="#_34、blob和text有什么区别" class="header-anchor">#</a> 34、Blob和text有什么区别？</h2> <blockquote><ul><li>Blob用于存储二进制数据，而Text用于存储大字符串。</li> <li>Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。</li> <li>text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。</li></ul></blockquote> <h2 id="_35、组合索引是什么-为什么需要注意组合索引中的顺序"><a href="#_35、组合索引是什么-为什么需要注意组合索引中的顺序" class="header-anchor">#</a> 35、组合索引是什么？为什么需要注意组合索引中的顺序？</h2> <blockquote><p>组合索引，用户可以在多个列上建立索引,这种索引叫做组合索引。</p> <p>因为InnoDB引擎中的索引策略的最左原则，所以需要注意组合索引中的顺序。</p></blockquote> <h2 id="_36、为什么要使用视图-什么是视图"><a href="#_36、为什么要使用视图-什么是视图" class="header-anchor">#</a> 36、为什么要使用视图？什么是视图？</h2> <p><strong>为什么要使用视图？</strong></p> <p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。</p> <p><strong>什么是视图？</strong></p> <blockquote><p>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。</p></blockquote> <h2 id="_37、视图有哪些特点-哪些使用场景"><a href="#_37、视图有哪些特点-哪些使用场景" class="header-anchor">#</a> 37、视图有哪些特点？哪些使用场景？</h2> <blockquote><p><strong>视图特点：</strong></p> <ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li> <li>视图是由基本表(实表)产生的表(虚表)。</li> <li>视图的建立和删除不影响基本表。</li> <li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li> <li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul> <p><strong>视图用途：</strong> 简化sql查询，提高开发效率，兼容老的表结构。</p> <p><strong>视图的常见使用场景：</strong></p> <ul><li>重用SQL语句；</li> <li>简化复杂的SQL操作。</li> <li>使用表的组成部分而不是整个表；</li> <li>保护数据</li> <li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul></blockquote> <h2 id="_38、视图的优点-缺点-讲一下"><a href="#_38、视图的优点-缺点-讲一下" class="header-anchor">#</a> 38、视图的优点，缺点，讲一下？</h2> <blockquote><ul><li>查询简单化。视图能简化用户的操作</li> <li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li> <li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ul></blockquote> <h2 id="_39、count-1-、count-与-count-列名-的区别"><a href="#_39、count-1-、count-与-count-列名-的区别" class="header-anchor">#</a> 39、count(1)、count(*) 与 count(列名) 的区别？</h2> <blockquote><ul><li>count(*)：包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li> <li>count(1)：包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li> <li>count(列名)：只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul></blockquote> <h2 id="_40、什么是存储过程-有哪些优缺点"><a href="#_40、什么是存储过程-有哪些优缺点" class="header-anchor">#</a> 40、什么是存储过程？有哪些优缺点？</h2> <blockquote><p><strong>存储过程</strong>，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。</p> <p><strong>优点：</strong></p> <ul><li>存储过程是一个预编译的代码块，执行效率比较高</li> <li>存储过程在服务器端运行，减少客户端的压力</li> <li>允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用</li> <li>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</li> <li>可以一定程度上确保数据安全</li></ul> <p><strong>缺点：</strong></p> <ul><li>调试麻烦</li> <li>可移植性不灵活</li> <li>重新编译问题</li></ul></blockquote> <h2 id="_41、什么是触发器-触发器的使用场景有哪些"><a href="#_41、什么是触发器-触发器的使用场景有哪些" class="header-anchor">#</a> 41、什么是触发器？触发器的使用场景有哪些？</h2> <blockquote><p><strong>触发器</strong>，指一段代码，当触发某个事件时，自动执行这些代码。</p> <p><strong>使用场景：</strong></p> <ul><li>可以通过数据库中的相关表实现级联更改。</li> <li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li> <li>例如可以生成某些业务的编号。</li> <li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li></ul></blockquote> <h2 id="_42、mysql中都有哪些触发器"><a href="#_42、mysql中都有哪些触发器" class="header-anchor">#</a> 42、MySQL中都有哪些触发器？</h2> <blockquote><p>MySQL 数据库中有六种触发器：</p> <ul><li>Before Insert</li> <li>After Insert</li> <li>Before Update</li> <li>After Update</li> <li>Before Delete</li> <li>After Delete</li></ul></blockquote> <h2 id="_43、drop、delete与truncate的区别"><a href="#_43、drop、delete与truncate的区别" class="header-anchor">#</a> 43、drop、delete与truncate的区别</h2> <table><thead><tr><th style="text-align:left;"></th> <th style="text-align:left;">delete</th> <th style="text-align:left;">truncate</th> <th>drop</th></tr></thead> <tbody><tr><td style="text-align:left;">类型</td> <td style="text-align:left;">DML</td> <td style="text-align:left;">DDL</td> <td>DDL</td></tr> <tr><td style="text-align:left;">回滚</td> <td style="text-align:left;">可回滚</td> <td style="text-align:left;">不可回滚</td> <td>不可回滚</td></tr> <tr><td style="text-align:left;">删除内容</td> <td style="text-align:left;">表结构还在，删除表的全部或者一部分数据行</td> <td style="text-align:left;">表结构还在，删除表中的所有数据</td> <td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr> <tr><td style="text-align:left;">删除速度</td> <td style="text-align:left;">删除速度慢，逐行删除</td> <td style="text-align:left;">删除速度快</td> <td>删除速度最快</td></tr></tbody></table> <h2 id="_44、列值为null时-查询是否会用到索引"><a href="#_44、列值为null时-查询是否会用到索引" class="header-anchor">#</a> 44、列值为NULL时，查询是否会用到索引？</h2> <blockquote><p>列值为NULL也是可以走索引的</p> <p>计划对列进行索引，应尽量避免把它设置为可空，因为这会让 MySQL 难以优化引用了可空列的查询，同时增加了引擎的复杂度</p></blockquote> <h2 id="_45、如果要存储用户的密码散列-应该使用什么字段进行存储"><a href="#_45、如果要存储用户的密码散列-应该使用什么字段进行存储" class="header-anchor">#</a> 45、如果要存储用户的密码散列，应该使用什么字段进行存储？</h2> <blockquote><p>密码散列，盐，用户身份证号等固定长度的字符串，应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p></blockquote> <h2 id="_46、innodb的事务实现原理"><a href="#_46、innodb的事务实现原理" class="header-anchor">#</a> 46、Innodb的事务实现原理？</h2> <blockquote><ul><li>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</li> <li>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</li> <li>隔离性：通过锁以及MVCC,使事务相互隔离开。</li> <li>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</li></ul></blockquote> <h2 id="_47、mysql中text数据类型的最大长度"><a href="#_47、mysql中text数据类型的最大长度" class="header-anchor">#</a> 47、MySQL中TEXT数据类型的最大长度</h2> <blockquote><ul><li>TINYTEXT：256 bytes</li> <li>TEXT：65,535 bytes(64kb)</li> <li>MEDIUMTEXT：16,777,215 bytes(16MB)</li> <li>LONGTEXT：4,294,967,295 bytes(4GB)</li></ul></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview/database/redis.html" class="prev">
        Redis
      </a></span> <span class="next"><a href="/interview/framework/Spring.html">
        Spring
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/assets/js/app.3819fb42.js" defer></script><script src="/assets/js/7.11ff0c83.js" defer></script><script src="/assets/js/51.3151143d.js" defer></script>
  </body>
</html>
