const e=JSON.parse('{"key":"v-645790bf","path":"/study-tutorial/advanced/designPatterns.html","title":"","lang":"zh-CN","frontmatter":{"description":"1、设计模式的目的\\r 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的，挑战设计模式是为 了让程序软件，具有更好：\\r - 代码重用性（相同功能的代码，不用多次编写）\\r - 可读性（编程规范性，便于其他程序员的阅读和理解）\\r - 可扩展性（当需要增加新的功能时，非常的方便，称为可维护性）\\r - 可靠性（当我们...","head":[["meta",{"property":"og:url","content":"https://javaxiaobear.cn/study-tutorial/advanced/designPatterns.html"}],["meta",{"property":"og:site_name","content":"小熊学Java 全能学习+面试指南"}],["meta",{"property":"og:description","content":"1、设计模式的目的\\r 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的，挑战设计模式是为 了让程序软件，具有更好：\\r - 代码重用性（相同功能的代码，不用多次编写）\\r - 可读性（编程规范性，便于其他程序员的阅读和理解）\\r - 可扩展性（当需要增加新的功能时，非常的方便，称为可维护性）\\r - 可靠性（当我们..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-21T11:19:08.000Z"}],["meta",{"property":"article:author","content":"小熊同学"}],["meta",{"property":"article:modified_time","content":"2023-09-21T11:19:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-21T11:19:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小熊同学\\",\\"url\\":\\"https://javaxiaobear.cn\\"}]}"]]},"headers":[{"level":2,"title":"1、设计模式的目的","slug":"_1、设计模式的目的","link":"#_1、设计模式的目的","children":[]},{"level":2,"title":"2、设计模式的七大原则","slug":"_2、设计模式的七大原则","link":"#_2、设计模式的七大原则","children":[{"level":3,"title":"1、单一职责原则","slug":"_1、单一职责原则","link":"#_1、单一职责原则","children":[]},{"level":3,"title":"2、接口隔离原则","slug":"_2、接口隔离原则","link":"#_2、接口隔离原则","children":[]},{"level":3,"title":"3、依赖倒转原则","slug":"_3、依赖倒转原则","link":"#_3、依赖倒转原则","children":[]},{"level":3,"title":"4、里氏替换原则","slug":"_4、里氏替换原则","link":"#_4、里氏替换原则","children":[]},{"level":3,"title":"5、开闭原则","slug":"_5、开闭原则","link":"#_5、开闭原则","children":[]},{"level":3,"title":"6、迪米特原则","slug":"_6、迪米特原则","link":"#_6、迪米特原则","children":[]},{"level":3,"title":"7、合成复用原则","slug":"_7、合成复用原则","link":"#_7、合成复用原则","children":[]}]},{"level":2,"title":"3、设计模式的核心思想","slug":"_3、设计模式的核心思想","link":"#_3、设计模式的核心思想","children":[]},{"level":2,"title":"4、设计模式的分类","slug":"_4、设计模式的分类","link":"#_4、设计模式的分类","children":[]},{"level":2,"title":"5、单例模式","slug":"_5、单例模式","link":"#_5、单例模式","children":[{"level":3,"title":"1、单例模式介绍","slug":"_1、单例模式介绍","link":"#_1、单例模式介绍","children":[]},{"level":3,"title":"2、单例模式的种类","slug":"_2、单例模式的种类","link":"#_2、单例模式的种类","children":[]},{"level":3,"title":"3、单例模式在JDK 应用的源码分析","slug":"_3、单例模式在jdk-应用的源码分析","link":"#_3、单例模式在jdk-应用的源码分析","children":[]},{"level":3,"title":"4、注意事项和细节说明","slug":"_4、注意事项和细节说明","link":"#_4、注意事项和细节说明","children":[]},{"level":3,"title":"5、总结","slug":"_5、总结","link":"#_5、总结","children":[]}]},{"level":2,"title":"6、工厂模式","slug":"_6、工厂模式","link":"#_6、工厂模式","children":[{"level":3,"title":"1、传统模式","slug":"_1、传统模式","link":"#_1、传统模式","children":[]},{"level":3,"title":"2、简单工厂模式","slug":"_2、简单工厂模式","link":"#_2、简单工厂模式","children":[]},{"level":3,"title":"3、工厂方法模式","slug":"_3、工厂方法模式","link":"#_3、工厂方法模式","children":[]},{"level":3,"title":"4、抽象工厂模式","slug":"_4、抽象工厂模式","link":"#_4、抽象工厂模式","children":[]},{"level":3,"title":"5、工厂模式在JDK-Calendar 应用的源码分析","slug":"_5、工厂模式在jdk-calendar-应用的源码分析","link":"#_5、工厂模式在jdk-calendar-应用的源码分析","children":[]},{"level":3,"title":"6、工厂模式小结","slug":"_6、工厂模式小结","link":"#_6、工厂模式小结","children":[]}]}],"git":{"createdTime":1695295148000,"updatedTime":1695295148000,"contributors":[{"name":"javaxiaobear","email":"2861184805@qq.com","commits":1}]},"readingTime":{"minutes":35.73,"words":10720},"filePathRelative":"study-tutorial/advanced/designPatterns.md","localizedDate":"2023年9月21日","copyright":{"author":"小熊学Java"},"autoDesc":true,"excerpt":""}');export{e as data};
