import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as t,e as s}from"./app-f55ccf80.js";const e={},i=s(`<h2 id="_1、java-中异常分为哪些种类" tabindex="-1"><a class="header-anchor" href="#_1、java-中异常分为哪些种类" aria-hidden="true">#</a> 1、Java 中异常分为哪些种类？</h2><blockquote><p>按照异常需要处理的时机分为<strong>编译时异常（也叫强制性异常）也叫 CheckedException</strong> 和<strong>运行时异常（也叫非强制性异常）也叫 RuntimeException</strong>。</p><p>只有 java 语言提供了 Checked 异常，Java 认为 Checked异常都是可以被处理的异常，所以 Java 程序必须显式处理 Checked 异常。如果程序没有处理 Checked 异常，该程序在编译时就会发生错误无法编译。这体现了 Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。</p><p>对 Checked 异常处理方法有两种：</p><ol><li>当前方法知道如何处理该异常，则用 try...catch 块来处理该异常。</li><li>当前方法不知道如何处理，则在定义该方法是声明抛出该异常。</li></ol><p>运行时异常只有当代码在运行时才发行的异常，编译时不需要 try catch。Runtime 如<strong>除数是 0</strong> 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p></blockquote><h2 id="_2、调用下面的方法-得到的返回值是什么" tabindex="-1"><a class="header-anchor" href="#_2、调用下面的方法-得到的返回值是什么" aria-hidden="true">#</a> 2、调用下面的方法，得到的返回值是什么？</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
       <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分析</strong>：</p><ol><li>代码走到第3行的时候，遇到了一个 MathException，因此第4行不会执行了，代码跳到catch里面</li><li>代码走到第6行的时候，异常机制有这么一个原则：如果在 catch 中遇到了 return 或者异常等能使该函数终止的话，那么有 finally 就必须先执行完 finally 代码块里面的代码，然后再返回值。因此跳到第8行。</li><li>第8行是一个return语句，这个时候就结束了，第6行的值无法被返回。返回值为3.</li><li>若第8行不是一个return语句，而是一个释放资源的操作，则返回值为2.</li></ol><h2 id="_3、error-和-exception-区别是什么" tabindex="-1"><a class="header-anchor" href="#_3、error-和-exception-区别是什么" aria-hidden="true">#</a> 3、Error 和 Exception 区别是什么？</h2><blockquote><ul><li><strong>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出</strong>等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li><li><strong>Exception 类的错误是可以在应用程序中进行捕获并处理的</strong>，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li></ul></blockquote><h2 id="_4、运行时异常和一般异常-受检异常-区别是什么" tabindex="-1"><a class="header-anchor" href="#_4、运行时异常和一般异常-受检异常-区别是什么" aria-hidden="true">#</a> 4、运行时异常和一般异常(受检异常)区别是什么？</h2><blockquote><ul><li><strong>运行时异常包括 RuntimeException 类及其子类</strong>，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</li><li>受<strong>检异常是Exception 中除 RuntimeException 及其子类之外的异常</strong>。 Java 编译器会检查受检异常。</li><li><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。</li><li>一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</li></ul></blockquote><h2 id="_5、throw-和-throws-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_5、throw-和-throws-的区别是什么" aria-hidden="true">#</a> 5、throw 和 throws 的区别是什么？</h2><blockquote><p><strong>throw:</strong></p><ul><li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。</li><li>throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。</li></ul><p><strong>throws:</strong></p><ul><li>throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。</li><li>throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这种异常。</li></ul></blockquote><h2 id="_6、final、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#_6、final、finally、finalize-的区别" aria-hidden="true">#</a> 6、final、finally、finalize 的区别？</h2><blockquote><p><strong>final</strong>：可用于修饰属性、方法、类。修饰的属性不可变（不能重新被赋值），方法不能重写，类不能继承。</p><p><strong>finally</strong>：异常处理语句try-catch的一部分，一般将一定要执行的代码放在finally代码块中，总是被执行，一般用来存放一些关闭资源的操作。</p><p><strong>finalize</strong>：Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。</p></blockquote><h2 id="_7、常见的-runtimeexception-有哪些" tabindex="-1"><a class="header-anchor" href="#_7、常见的-runtimeexception-有哪些" aria-hidden="true">#</a> 7、常见的 RuntimeException 有哪些？</h2><blockquote><ul><li><strong>ClassCastException</strong>：数据类型转换异常</li><li><strong>IndexOutOfBoundsException</strong>：数组下标越界异常，常见于操作数组对象时发生。</li><li><strong>NullPointerException</strong>：空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。</li><li><strong>ClassNotFoundException</strong>：指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。</li><li><strong>NumberFormatException</strong>：字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。</li><li><strong>IllegalArgumentException</strong>：方法传递参数异常</li><li><strong>NoClassDefFoundException</strong>：未找到定义类异常</li><li><strong>SQLException SQL</strong>：常见于操作数据库时的 SQL 语句错误。</li><li><strong>InstantiationException</strong>：实例化异常。</li><li><strong>NoSuchMethodException</strong>：方法不存在异常</li><li><strong>ArrayStoreException</strong>：数据存储异常，操作数组时类型不一致</li><li>还有IO操作的BufferOverflowException异常</li></ul></blockquote><h2 id="_8、finally内存回收的情况" tabindex="-1"><a class="header-anchor" href="#_8、finally内存回收的情况" aria-hidden="true">#</a> 8、finally内存回收的情况？</h2><blockquote><ol><li>如果在try... catch 部分用Connection 对象连接了数据库，而且在后继部台不会再用到这个连接对象，那么一定要在 finally从句中关闭该连接对象， 否则该连接对象所占用的内存资源无法被回收。</li><li>如果在try... catch 部分用到了一些IO对象进行了读写操作，那么也一定要在finally 中关闭这些IO对象，否则，IO对象所占用的内存资源无法被回收。</li><li>如果在try .catch 部分用到了ArrayList 、Linkedlist 、Hash Map 等集合对象，而且这些对象之后不会再被用到，那么在finally中建议通过调用clear方法来清空这些集合。</li><li>例如，在try .catch 语句中育一个对象obj 指向7一块比较大的内存空间（假设100MB) ，而且之后不会再被用到，那么在 finally 从句中建议写上 obj=null，这样能提升内存使用效率。</li></ol></blockquote><h2 id="_9、异常的设计原则有哪些" tabindex="-1"><a class="header-anchor" href="#_9、异常的设计原则有哪些" aria-hidden="true">#</a> 9、异常的设计原则有哪些？</h2><blockquote><ul><li>不要将异常处理用于正常的控制流</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常</li></ul></blockquote>`,20),o=[i];function l(r,c){return a(),t("div",null,o)}const d=n(e,[["render",l],["__file","exception.html.vue"]]);export{d as default};
