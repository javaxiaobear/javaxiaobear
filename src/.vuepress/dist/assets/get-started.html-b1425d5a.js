import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c,a as s,b as n,d as e,e as p}from"./app-aeb4ead9.js";const o={},r=s("h3",{id:"_1、redis简介",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_1、redis简介","aria-hidden":"true"},"#"),n(" 1、redis简介")],-1),d=s("strong",null,"Redis",-1),u={href:"https://zh.wikipedia.org/wiki/ANSI_C",target:"_blank",rel:"noopener noreferrer"},m={href:"https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90",target:"_blank",rel:"noopener noreferrer"},k={href:"https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C",target:"_blank",rel:"noopener noreferrer"},v={href:"https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98",target:"_blank",rel:"noopener noreferrer"},b={href:"https://zh.wikipedia.org/w/index.php?title=%E6%8C%81%E4%B9%85%E6%80%A7_(%E6%95%B0%E6%8D%AE%E5%BA%93)&action=edit&redlink=1",target:"_blank",rel:"noopener noreferrer"},h=s("p",null,"它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。",-1),g=p(`<h3 id="_2、linux安装" tabindex="-1"><a class="header-anchor" href="#_2、linux安装" aria-hidden="true">#</a> 2、linux安装</h3><h4 id="_1、下载" tabindex="-1"><a class="header-anchor" href="#_1、下载" aria-hidden="true">#</a> 1、下载</h4><ul><li><p>在线下载</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ wget http<span class="token operator">:</span><span class="token comment">//download.redis.io/releases/redis-5.0.7.tar.gz</span>
$ tar xzf redis<span class="token operator">-</span><span class="token number">5.0</span><span class="token number">.7</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">-</span>C <span class="token operator">/</span>root<span class="token operator">/</span>tool <span class="token comment">//解压到指定目录</span>
$ cd redis<span class="token operator">-</span><span class="token number">5.0</span><span class="token number">.7</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
$ make
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>利用ftp等软件上传至Linux桌面</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ tar xzf redis<span class="token operator">-</span><span class="token number">5.0</span><span class="token number">.7</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
$ cd redis<span class="token operator">-</span><span class="token number">5.0</span><span class="token number">.7</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
$ make
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**注：**我们需要将源码编译后再安装，因此需要安装 c 语言的编译环境！不能直接 make</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>yum install gcc<span class="token operator">-</span>c<span class="token operator">++</span> <span class="token operator">-</span>y
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><mark>make时遇到的错误：</mark></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>In file included from adlist<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">34</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
zmalloc<span class="token punctuation">.</span>h<span class="token operator">:</span><span class="token number">50</span><span class="token operator">:</span><span class="token number">31</span><span class="token operator">:</span> fatal error<span class="token operator">:</span> jemalloc<span class="token operator">/</span>jemalloc<span class="token punctuation">.</span>h<span class="token operator">:</span> No such file or directory
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;jemalloc/jemalloc.h&gt;</span></span>
                               <span class="token operator">^</span>
compilation terminated<span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解决办法：<mark>make MALLOC=libc</mark></strong></p></li></ul><h4 id="_2、安装" tabindex="-1"><a class="header-anchor" href="#_2、安装" aria-hidden="true">#</a> 2、安装</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>make PREFIX<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>redis instal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装到指定目录，若没有，则创建该目录；PREFIX必须大写</p><h4 id="_3、启动服务端跟客户端" tabindex="-1"><a class="header-anchor" href="#_3、启动服务端跟客户端" aria-hidden="true">#</a> 3、启动服务端跟客户端</h4><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/20200401214417.png" alt="" loading="lazy"></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>server
<span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis服务器默认会使用6379端口1) , 通过－－port参数可以自定义端口号：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>redis<span class="token operator">-</span>server <span class="token operator">--</span>port <span class="token number">6380</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_4、关闭" tabindex="-1"><a class="header-anchor" href="#_4、关闭" aria-hidden="true">#</a> 4、关闭</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>shutdown
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_5、docker安装redis" tabindex="-1"><a class="header-anchor" href="#_5、docker安装redis" aria-hidden="true">#</a> 5、docker安装redis</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>docker search redis        <span class="token comment">//命令来查看可用版本</span>
    
docker pull redis<span class="token operator">:</span>latest   <span class="token comment">//拉取官方的最新版本的镜像</span>
    
docker images              <span class="token comment">//查看镜像</span>
 
docker run <span class="token operator">-</span>d <span class="token operator">--</span>name redis<span class="token operator">-</span>test <span class="token operator">-</span>p <span class="token number">6379</span><span class="token operator">:</span><span class="token number">6379</span> redis <span class="token operator">--</span>requirepass <span class="token string">&quot;密码&quot;</span><span class="token comment">//创建并运行容器</span>
  <span class="token comment">//  --requirepass 密码 -d: 后台运行容器，并返回容器ID；</span>
docker exec <span class="token operator">-</span>it redis redis<span class="token operator">-</span>cli <span class="token operator">-</span>a 密码            <span class="token comment">//运行客户端 --it 交互</span>
 
<span class="token comment">/*docker常用命令
1、docker ps 查看进程
2、docker container rm 删除容器
https://www.runoob.com/docker/docker-command-manual.html
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、redis配置" tabindex="-1"><a class="header-anchor" href="#_3、redis配置" aria-hidden="true">#</a> 3、redis配置</h3><h4 id="_1、redis-conf" tabindex="-1"><a class="header-anchor" href="#_1、redis-conf" aria-hidden="true">#</a> 1、redis.conf</h4><h4 id="_2、内存维护策略-缓存清理策略" tabindex="-1"><a class="header-anchor" href="#_2、内存维护策略-缓存清理策略" aria-hidden="true">#</a> 2、内存维护策略（缓存清理策略）</h4><ol><li><table><thead><tr><th style="text-align:left;">属性</th><th style="text-align:center;">含义</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:left;">bind</td><td style="text-align:center;">限定访问的主机地</td><td style="text-align:left;">如果没有bind，就是任意ip 地址都可以访问。生产环境下，需要写自己应用服务器的ip 地址。</td></tr><tr><td style="text-align:left;">protected-mode</td><td style="text-align:center;">安全防护模式</td><td style="text-align:left;">如果没有指定bind 指令，也没有配置密码，那么保护模式就开启，只允许本机访问。</td></tr><tr><td style="text-align:left;">port</td><td style="text-align:center;">端口号</td><td style="text-align:left;">默认是6379</td></tr><tr><td style="text-align:left;">timeout</td><td style="text-align:center;">超时时间</td><td style="text-align:left;">默认永不超时</td></tr><tr><td style="text-align:left;">daemonize</td><td style="text-align:center;">是否为守护进程模式运行</td><td style="text-align:left;">守护进程模式可以在后台运行，默认是no</td></tr><tr><td style="text-align:left;">pidfile</td><td style="text-align:center;">进程id 文件保存的路径</td><td style="text-align:left;">配置PID 文件路径，当redis 作为守护进程运行的时候，它会把pid默认写到/var/redis/run/redis_6379.pid 文件里面</td></tr><tr><td style="text-align:left;">logfile</td><td style="text-align:center;">日志文件的位置</td><td style="text-align:left;">当指定为空字符串时，为标准输出，如果redis 以守护进程模式运行，那么日志将会输出到/dev/null</td></tr><tr><td style="text-align:left;">databases</td><td style="text-align:center;">设置数据库数量</td><td style="text-align:left;">默认是0</td></tr><tr><td style="text-align:left;">requirepass</td><td style="text-align:center;">设置密码</td><td style="text-align:left;">默认没有，但远程连接可能会连接不上</td></tr><tr><td style="text-align:left;">maxclients</td><td style="text-align:center;">最大连接数</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">maxmemory</td><td style="text-align:center;">最大占用多少内存</td><td style="text-align:left;">一旦占用内存超限，就开始根据缓存清理策略移除数据如果Redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么Redis 则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH 等。</td></tr><tr><td style="text-align:left;"><strong>maxmemory-policy noeviction</strong></td><td style="text-align:center;"><strong>缓存清理策略</strong></td><td style="text-align:left;"><strong>（1）volatile-lru：使用LRU 算法移除key，只对设置了过期时间的键<br>（2）allkeys-lru：使用LRU 算法移除key<br>（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键<br>（4）allkeys-random：移除随机的key<br>（5）volatile-ttl：移除那些TTL 值最小的key，即那些最近要过期的key<br>（6）noeviction：不进行移除。针对写操作，只是返回错误信息</strong></td></tr></tbody></table></li></ol><h3 id="_4、redis基本操作" tabindex="-1"><a class="header-anchor" href="#_4、redis基本操作" aria-hidden="true">#</a> 4、Redis基本操作</h3><h4 id="_1、数据库" tabindex="-1"><a class="header-anchor" href="#_1、数据库" aria-hidden="true">#</a> 1、数据库</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>select <span class="token operator">&lt;</span>dbid<span class="token operator">&gt;</span>  <span class="token comment">//切换数据库 select 1 切换到1号数据库，默认为0</span>
flushdb        <span class="token comment">//清空当前库</span>
dbsize         <span class="token comment">//查看数据库个数</span>
flushall       <span class="token comment">//通杀全部库</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2、key" tabindex="-1"><a class="header-anchor" href="#_2、key" aria-hidden="true">#</a> 2、Key</h4><p>Redis 中的数据以<strong>键值对（key-value）<strong>为基本存储方式，其中</strong>key 都是字符串</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>KEYS pattern   <span class="token comment">//查询符合指定表达式的所有key，支持*，？等</span>
TYPE key       <span class="token comment">//查看key 对应值的类型</span>
EXISTS key     <span class="token comment">//指定的key 是否存在，0 代表不存在，1 代表存在</span>
DEL key       <span class="token comment">//删除指定key</span>
RANDOMKEY     <span class="token comment">//在现有的KEY 中随机返回一个</span>
EXPIRE key seconds   <span class="token comment">//为键值设置过期时间，单位是秒，过期后key 会被redis 移除</span>
TTL key       <span class="token comment">//查看key 还有多少秒过期，-1 表示永不过期，-2 表示已过期</span>
RENAME key newkey
<span class="token comment">//重命名一个key，NEWKEY 不管是否是已经存在的都会执行，如果NEWKEY 已经存在则会被覆盖</span>
RENAMENX key newkey  <span class="token comment">//只有在NEWKEY 不存在时能够执行成功，否则失败</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200404225335437.png" alt="image-20200404225335437" loading="lazy"></p><h4 id="_3、string" tabindex="-1"><a class="header-anchor" href="#_3、string" aria-hidden="true">#</a> 3、String</h4><p>String 类型是Redis 中最基本的类型，它是key 对应的一个单一值。</p><p>二进制安全，不必担心由于编码等问题导致二进制数据变化。所以redis 的string 可以包含任何数据，比如jpg</p><p>图片或者序列化的对象。Redis 中一个字符串值的最大容量是512M。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>SET key value              <span class="token comment">//添加键值对</span>
GET key                    <span class="token comment">//查询指定key 的值</span>
APPEND key value           <span class="token comment">//将给定的value 追加到原值的末尾</span>
STRLEN key                <span class="token comment">//获取值的长度</span>
SETNX key value           <span class="token comment">//只有在key 不存在时设置key 的值</span>
INCR key                  <span class="token comment">//指定key 的值自增1，只对数字有效</span>
DECR key                  <span class="token comment">//指定key 的值自减1，只对数字有效</span>
INCRBY key num            <span class="token comment">//自增num</span>
DECRBY key num            <span class="token comment">//自减num</span>
MSET key1 value1 key2 value2…    <span class="token comment">//同时设置多个key-value 对</span>
MGET key1 key2            <span class="token comment">//同时获取一个或多个value</span>
MSETNX key1 value1 key2 value2   <span class="token comment">//当key 不存在时，设置多个key-value 对</span>
GETRANGE key 起始索引 结束索       <span class="token comment">//获取指定范围的值，都是闭区间</span>
SETRANGE key 起始索引value        <span class="token comment">//从起始位置开始覆写指定的值</span>
GETSET key value                 <span class="token comment">//以新换旧，同时获取旧值</span>
SETEX key 过期时间value           <span class="token comment">//设置键值的同时，设置过期时间，单位秒</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200404230347984.png" alt="image-20200404230347984" loading="lazy"></p><h4 id="_4、list" tabindex="-1"><a class="header-anchor" href="#_4、list" aria-hidden="true">#</a> 4、List</h4><p>Redis列表是简单的字符串列表，按照插入<strong>顺序排序</strong>。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p><p>常见操作：</p><p><strong>遍历：遍历的时候，是从左往右取值；</strong></p><p><strong>删除：弹栈，POP；</strong></p><p><strong>添加：压栈，PUSH ；</strong></p><p>它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>LPUSH<span class="token operator">/</span>RPUSH key value1 value2…  <span class="token comment">//从左边/右边压入一个或多个值,头尾效率高，中间效率低</span>
LPOP<span class="token operator">/</span>RPOP key                   <span class="token comment">//从左边/右边弹出一个值,值在键在，值光键亡,弹出=返回+删除</span>
LRANGE key start stop          <span class="token comment">//查看指定区间的元素,正着数：0,1,2,3,...倒着数：-1,-2,-3,...</span>
LINDEX key index              <span class="token comment">//按照索引下标获取元素（从左到右）</span>
LLEN key                      <span class="token comment">//获取列表长度</span>
LINSERT key BEFORE<span class="token operator">|</span>AFTER value newvalue <span class="token comment">//在指定value 的前后插入newvalue</span>
LREM key n value             <span class="token comment">//从左边删除n 个value</span>
LSET key index value         <span class="token comment">//把指定索引位置的元素替换为另一个值</span>
LTRIM key start stop         <span class="token comment">//仅保留指定区间的数据</span>
RPOPLPUSH key1 key2         <span class="token comment">//从key1 右边弹出一个值，左侧压入到key2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200405152307205.png" alt="image-20200405152307205" loading="lazy"></p><h4 id="_5、set" tabindex="-1"><a class="header-anchor" href="#_5、set" aria-hidden="true">#</a> 5、Set</h4><p>####### <mark>set 是无序的，且是不可重复的。</mark></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> 
<span class="token comment">//将一个或多个member 元素加入到集合key 当中，已经存在于集合的member 元素将被忽略。</span>
SMEMBERS key                     <span class="token comment">//取出该集合的所有值</span>
SISMEMBER key value              <span class="token comment">//判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有返回1，没有返回0</span>
SCARD key                        <span class="token comment">//返回集合中元素的数量</span>
SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token comment">//从集合中删除元素</span>
SPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>                <span class="token comment">//从集合中随机弹出count 个数量的元素，count 不指定就弹出1 个</span>
SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>         <span class="token comment">//从集合中随机返回count 个数量的元素，count 不指定就返回1 个</span>
SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>            <span class="token comment">//将指定的集合进行“交集”操作</span>
SINTERSTORE dest key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  <span class="token comment">//取交集，另存为一个set</span>
SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>             <span class="token comment">//将指定的集合执行“并集”操作</span>
SUNIONSTORE dest key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  <span class="token comment">//取并集，另存为set</span>
SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>             <span class="token comment">//将指定的集合执行“差集”操作</span>
SDIFFSTORE dest key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  <span class="token comment">//取差集，另存为set</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200405153111672.png" alt="image-20200405153111672" loading="lazy"></p><h4 id="_6、hash" tabindex="-1"><a class="header-anchor" href="#_6、hash" aria-hidden="true">#</a> 6、Hash</h4><p>Hash 数据类型的键值对中的值是“单列”的，不支持进一步的层次结构。hash 特别适合用于<strong>存储对象</strong>。</p><p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//从前到后的数据对应关系</span>
<span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;yhx&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>HSET key field value                          <span class="token comment">//为key 中的field 赋值value</span>
HMSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>       <span class="token comment">//为指定key 批量设置field-value</span>
HSETNX key field value                        <span class="token comment">//当指定key 的field 不存在时，设置其value</span>
HGETALL key                                   <span class="token comment">//获取指定key 的所有信息（field 和value）</span>
HKEYS key                                     <span class="token comment">//获取指定key 的所有field</span>
HVALS key                                     <span class="token comment">//获取指定key 的所有value</span>
HLEN key                                     <span class="token comment">//指定key 的field 个数</span>
HGET key field                               <span class="token comment">//从key 中根据field 取出value</span>
HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>                  <span class="token comment">//为指定key 获取多个filed 的值</span>
HEXISTS key field                            <span class="token comment">//指定key 是否有field</span>
HINCRBY key field increment                  <span class="token comment">//为指定key 的field 加上增量increment</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200405154227541.png" alt="image-20200405154227541" loading="lazy"></p><h4 id="_7、zset" tabindex="-1"><a class="header-anchor" href="#_7、zset" aria-hidden="true">#</a> 7、Zset</h4><p>zset 是一种特殊的set（sorted set），在保存value 的时候，为每个value 多保存了一个score 信息。根据score 信息，可以进行排序。</p><p>这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可 以是重复了</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ZADD key <span class="token punctuation">[</span>score member <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>               <span class="token comment">//添加</span>
ZSCORE key member                        <span class="token comment">//返回指定值的分数</span>
ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>      <span class="token comment">//返回指定区间的值，可选择是否一起返回scores</span>
ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span><span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
<span class="token comment">//在分数的指定区间内返回数据，从小到大排列</span>
ZREVRANGEBYSCORE key max min<span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
<span class="token comment">//在分数的指定区间内返回数据，从大到小排列</span>
ZCARD key                               <span class="token comment">//返回集合中所有的元素的数量</span>
ZCOUNT key min max                      <span class="token comment">//统计分数区间内的元素个数</span>
ZREM key member                        <span class="token comment">//删除该集合下，指定值的元素</span>
ZRANK key member                       <span class="token comment">//返回该值在集合中的排名，从0 开始</span>
ZINCRBY key increment value            <span class="token comment">//为元素的score 加上增量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200405154822259.png" alt="image-20200405154822259" loading="lazy"></p><h4 id="_8、hyperloglog" tabindex="-1"><a class="header-anchor" href="#_8、hyperloglog" aria-hidden="true">#</a> 8、HyperLogLog</h4><p>Redis 在 <strong>2.8.9 版本添加了 HyperLogLog 结构</strong>。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，<mark>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</mark></p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h6 id="什么是基数" tabindex="-1"><a class="header-anchor" href="#什么是基数" aria-hidden="true">#</a> 什么是基数?</h6><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是</p><p>在误差可接受的范围内，快速计算基数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>PFADD key element <span class="token punctuation">[</span>element <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>               <span class="token comment">//添加指定元素到 HyperLogLog 中。</span>
PFCOUNT key <span class="token punctuation">[</span>key <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>                         <span class="token comment">//返回给定 HyperLogLog 的基数估算值。</span>
PFMERGE destkey sourcekey <span class="token punctuation">[</span>sourcekey <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>     <span class="token comment">//将多个 HyperLogLog 合并为一个 HyperLogLog</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200405155752941.png" alt="image-20200405155752941" loading="lazy"></p><h6 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h6><ul><li>统计注册ip数</li><li>统计每日访问IP数</li><li>统计页面实时uv数</li><li>统计在线用户数</li><li>统计用户每天搜索不同词条的个数</li><li>统计真实文章阅读数</li></ul><h4 id="_9、redis发布订阅" tabindex="-1"><a class="header-anchor" href="#_9、redis发布订阅" aria-hidden="true">#</a> 9、redis发布订阅</h4><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406201522100.png" alt="" loading="lazy"></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>            <span class="token comment">//订阅给定的一个或多个频道的信息。</span>
PUBLISH channel message                    <span class="token comment">//将信息发送到指定的频道。</span>
PUBSUB subcommand <span class="token punctuation">[</span>argument <span class="token punctuation">[</span>argument <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment">//查看订阅与发布系统状态。</span>
PSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>           <span class="token comment">//订阅一个或多个符合给定模式的频道。</span>
UNSUBSCRIBE <span class="token punctuation">[</span>channel <span class="token punctuation">[</span>channel <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment">//指退订给定的频道。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、持久化" tabindex="-1"><a class="header-anchor" href="#_5、持久化" aria-hidden="true">#</a> 5、持久化</h3><p>Redis 主要是<strong>工作在内存中</strong>。内存本身就不是一个持久化设备，断电后数据会清空。所以Redis 在工作过程中，如果发生了意外停电事故，如何尽可能减少数据丢失。</p><h4 id="_1、rdb" tabindex="-1"><a class="header-anchor" href="#_1、rdb" aria-hidden="true">#</a> 1、RDB</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot 快照，它恢复时是将<strong>快照文件直接读到内存里。</strong> ==工作机制：每隔一段时间，就把内存中的数据保存到硬盘上的指定文件中。==RDB 是默认开启的！</p><blockquote><p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO 操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB 方式要比AOF 方式更加的高效。 RDB 的缺点是<strong>最后一次持久化后的数据可能丢失。</strong></p></blockquote><h5 id="_1、rdb保存策略" tabindex="-1"><a class="header-anchor" href="#_1、rdb保存策略" aria-hidden="true">#</a> 1、RDB保存策略</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>save <span class="token number">900</span> <span class="token number">1</span>      <span class="token comment">//900 秒内如果至少有1 个key 的值变化，则保存</span>
save <span class="token number">300</span> <span class="token number">10</span>     <span class="token comment">//300 秒内如果至少有10 个key 的值变化，则保存</span>
save <span class="token number">60</span> <span class="token number">10000</span>   <span class="token comment">//60 秒内如果至少有10000 个key 的值变化，则保存</span>
save “”         <span class="token comment">//就是禁用RDB 模式；</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2、rdb-常用属性配置" tabindex="-1"><a class="header-anchor" href="#_2、rdb-常用属性配置" aria-hidden="true">#</a> 2、RDB 常用属性配置</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>save                        <span class="token comment">//保存策略</span>
dbfilename RDB              <span class="token comment">//快照文件名</span>
dir RDB                     <span class="token comment">//快照保存的目录必须是一个目录，不能是文件名。最好改为固定目录。默认为./代表执行redis-server 命令时的当前目录！</span>
    
stop<span class="token operator">-</span>writes<span class="token operator">-</span>on<span class="token operator">-</span>bgsave<span class="token operator">-</span>error 
    <span class="token comment">//是否在备份出错时，继续接受写操作如果用户开启了RDB 快照功能，那么在redis 持久化数据到磁盘时如果出现失败，默认情况下，redis 会停止接受所有的写请求</span>
    
rdbcompression             
    <span class="token comment">//对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用LZF 算法进行压缩。如果你不想消耗CPU 来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</span>
    
rdbchecksum                 
    <span class="token comment">//是否进行数据校验在存储快照后，我们还可以让redis 使用CRC64 算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3、rdb-数据丢失的情况" tabindex="-1"><a class="header-anchor" href="#_3、rdb-数据丢失的情况" aria-hidden="true">#</a> 3、RDB 数据丢失的情况</h5><p><strong>两次保存的时间间隔内，服务器宕机，或者发生断电问题。</strong></p><h5 id="_4、rdb-的触发" tabindex="-1"><a class="header-anchor" href="#_4、rdb-的触发" aria-hidden="true">#</a> 4、RDB 的触发</h5><p>​ ① 基于自动保存的策略</p><p>​ ② 执行save，或者bgsave 命令！执行时，是阻塞状态。</p><p>​ ③ 执行flushdb 命令，也会产生dump.rdb，但里面是空的，没有意义。</p><p>​ ④ 当执行shutdown 命令时，也会主动地备份数据。</p><h5 id="_5、rdb的优缺点" tabindex="-1"><a class="header-anchor" href="#_5、rdb的优缺点" aria-hidden="true">#</a> 5、RDB的优缺点</h5><p><strong>RDB优点：</strong></p><p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备。 （2）RDB对redis对外提供读写服务的时候，影像非常小，因为redis 主进程只需要fork一个子进程出来，让子进程对磁盘io来进行rdb持久化 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</p><p>（4）RDB 适合用于灾难恢复，因为它只有一个文件，而且体积小，方便拷贝。</p><p><strong>RDB缺点：</strong></p><p>（1）如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，例如1:00进行的快照，在1:10又要进行快照的时候宕机了，这个时候就会丢失10分钟的数据。 （2）RDB每次fork出子进程来执行RDB快照生成文件时，如果文件特别大，可能会导致客户端提供服务暂停数毫秒或者几秒</p><h4 id="_2、aof" tabindex="-1"><a class="header-anchor" href="#_2、aof" aria-hidden="true">#</a> 2、AOF</h4><ul><li>AOF 是 以日志的形式来记录每个写操作，将每一次对数据进行修改，都把新建、修改数据的命令保存到指 定文件中。Redis 重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。</li><li>默认不开启，需要手动开启</li><li>AOF 文件的保存路径，同RDB 的路径一致。</li><li>AOF 在保存命令的时候，只会保存对数据有修改的命令，也就是写操作！</li><li>当RDB 和AOF 存的不一致的情况下，按照AOF 来恢复。因为AOF 是对RDB 的补充。备份周期更短，也就更 可靠。</li></ul><h5 id="_1、aof-保存策略" tabindex="-1"><a class="header-anchor" href="#_1、aof-保存策略" aria-hidden="true">#</a> 1、AOF 保存策略</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>appendfsync always：每次产生一条新的修改数据的命令都执行保存操作；效率低，但是安全！
appendfsync everysec：每秒执行一次保存操作。如果在未保存当前秒内操作时发生了断电，仍然会导致一部分数据丢失（即<span class="token number">1</span> 秒钟的数据）。
appendfsync no：从不保存，将数据交给操作系统来处理。更快，也更不安全的选择。
推荐（并且也是默认）的措施为每秒fsync 一次， 这种fsync 策略可以兼顾速度和安全性。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2、aof-常用属性" tabindex="-1"><a class="header-anchor" href="#_2、aof-常用属性" aria-hidden="true">#</a> 2、AOF 常用属性</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>appendonly                   <span class="token comment">//是否开启AOF 功能默认是关闭的</span>
appendfilename               <span class="token comment">//AOF文件名称</span>
appendfsync AOF              <span class="token comment">//保存策略官方建议everysec</span>
no<span class="token operator">-</span>appendfsync<span class="token operator">-</span>on<span class="token operator">-</span>rewrite     
    <span class="token comment">//在重写时，是否执行保存策略执行重写，可以节省AOF 文件的体积；而且在恢复的时候效率也更高。</span>
<span class="token keyword">auto</span><span class="token operator">-</span>aof<span class="token operator">-</span>rewrite<span class="token operator">-</span>percentage   
    <span class="token comment">//重写的触发条件当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写</span>
<span class="token keyword">auto</span><span class="token operator">-</span>aof<span class="token operator">-</span>rewrite<span class="token operator">-</span>min<span class="token operator">-</span>size     
    <span class="token comment">//设置允许重写的最小aof文件大小,避免了达到约定百分比但尺寸仍然很小的情况还要重写</span>
aof<span class="token operator">-</span>load<span class="token operator">-</span>truncated            
    <span class="token comment">//截断设置如果选择的是yes，当截断的aof 文件被导入的时候，会自动发布一个log 给客户端然后load</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3、aof-文件的修复" tabindex="-1"><a class="header-anchor" href="#_3、aof-文件的修复" aria-hidden="true">#</a> 3、AOF 文件的修复</h5><p>如果AOF 文件中出现了残余命令，会导致服务器无法重启。此时需要借助redis-check-aof 工具来修复！</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>redis<span class="token operator">-</span>check<span class="token operator">-</span>aof –fix 文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_4、aof-的优缺点" tabindex="-1"><a class="header-anchor" href="#_4、aof-的优缺点" aria-hidden="true">#</a> 4、AOF 的优缺点</h5><p><strong>AOF的优点：</strong></p><p>（1）AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果</p><p>redis进程挂掉，最多丢失1秒的数据。</p><p>（2）AOF以appen-only的模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。9</p><p>（3）AOF日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删除紧急恢复，如果某人不</p><p>小心用flushall命令清空了所有数据，只要这个时候还没有执行rewrite，那么就可以将日志文件中的flushall删除，</p><p>进行恢复。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- 备份机制更稳健，丢失数据概率更低
- 可读的日志文本，通过操作AOF 稳健，可以处理误操作
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>AOF的缺点：</strong></p><p>（1）对于同一份文件AOF文件比RDB数据快照要大。</p><p>（2）AOF开启后支持写的QPS会比RDB支持的写的QPS低，因为AOF一般会配置成每秒fsync操作，每秒的fsync</p><p>操作还是很高的</p><p>（3）数据恢复比较慢，不适合做冷备。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- 比起RDB 占用更多的磁盘空间
- 恢复备份速度要慢
- 每次读写都同步的话，有一定的性能压力
- 存在个别Bug，造成恢复不能
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3、备份建议" tabindex="-1"><a class="header-anchor" href="#_3、备份建议" aria-hidden="true">#</a> 3、备份建议</h4><p><strong>如何看待数据“绝对”安全？</strong></p><blockquote><p>Redis 作为内存数据库从本质上来说，如果不想牺牲性能，就不可能做到数据的“绝对”安全。 RDB 和AOF 都只是尽可能在兼顾性能的前提下降低数据丢失的风险，如果真的发生数据丢失问题，尽可能 减少损失。 在整个项目的架构体系中，Redis 大部分情况是扮演“二级缓存”角色。</p><p>二级缓存适合保存的数据</p><ul><li><p>经常要查询，很少被修改的数据。</p></li><li><p>不是非常重要，允许出现偶尔的并发问题。</p></li><li><p>不会被其他应用程序修改。</p><p>如果Redis 是作为缓存服务器，那么说明数据在MySQL 这样的传统关系型数据库中是有正式版本的。数据最终以MySQL 中的为准。</p></li></ul></blockquote><p><strong>RDB和AOF到底如何选择?</strong></p><p>（1）不要仅仅使用RDB这样会丢失很多数据。</p><p>（2）也不要仅仅使用AOF，因为这会有两个问题，第一通过AOF做冷备没有RDB做冷备恢复的速度快；第二</p><p>RDB每次简单粗暴生成数据快照，更加健壮。</p><p>（3）综合AOF和RDB两种持久化方式，用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程</p><p>度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。</p><p><strong>官方推荐两个都用：</strong><mark>如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是 做纯内存缓存，可以都不用</mark></p><h3 id="_6、事务" tabindex="-1"><a class="header-anchor" href="#_6、事务" aria-hidden="true">#</a> 6、事务</h3><p><strong>Redis 事务可以一次执行多个命令</strong>， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h4 id="_1、事务简介" tabindex="-1"><a class="header-anchor" href="#_1、事务简介" aria-hidden="true">#</a> 1、事务简介</h4><ul><li>Redis 中事务，不同于传统的关系型数据库中的事务。</li><li>Redis 中的事务指的是一个单独的隔离操作。</li><li>Redis 的事务中的所有命令都会序列化、按顺序地执行且不会被其他客户端发送来的命令请求所打</li><li>Redis 事务的主要作用是串联多个命令防止别的命令插队</li></ul><h4 id="_2、常用命令" tabindex="-1"><a class="header-anchor" href="#_2、常用命令" aria-hidden="true">#</a> 2、常用命令</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>MULTI          <span class="token comment">//标记一个事务块的开始</span>

EXEC           
                <span class="token comment">//执行所有事务块内的命令。执行事务中所有在排队等待的指令并将链接状态恢复到正常当使用WATCH时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行</span>
                
WATCH           <span class="token comment">//标记所有指定的key 被监视起来，在事务中有条件的执行（乐观锁）</span>

UNWATCH         <span class="token comment">//取消 WATCH 命令对所有 key 的监视。</span>

DISCARD         
<span class="token comment">//刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常。如果已使用WATCH，DISCARD将释放所有被WATCH 的key。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406215622035.png" alt="image-20200406215622035" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406221329363.png" alt="image-20200406221329363" loading="lazy"></p><p><strong>MULTI 开启组队，EXEC 依次执行队列中的命令。</strong></p><p><strong>DISCARD 中途取消组队</strong></p><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406215934571.png" alt="image-20200406215934571" loading="lazy"></p><h4 id="_3、错误命令处理" tabindex="-1"><a class="header-anchor" href="#_3、错误命令处理" aria-hidden="true">#</a> 3、错误命令处理</h4><p>1、此种情况，语法符合规范，Redis 只有在执行中，才可以发现错误。而在Redis 中，并没有回滚机制，因此错误的命令，无法执行，正确的命令会全部执行！</p><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406220325713.png" alt="image-20200406220325713" loading="lazy"></p><p>2、在编译的过程中，Redis 检测出来了错误的语法命令，因此它认为这条组队，一定会发生错误，因此全体取消；</p><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200406220528937.png" alt="image-20200406220528937" loading="lazy"></p><h4 id="_4、锁" tabindex="-1"><a class="header-anchor" href="#_4、锁" aria-hidden="true">#</a> 4、锁</h4><h5 id="_1、悲观锁" tabindex="-1"><a class="header-anchor" href="#_1、悲观锁" aria-hidden="true">#</a> 1、悲观锁</h5><p>执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关</p><p>资源锁定，不允许自己执行期间有其他操作干扰。</p><p>Redis 不支持悲观锁。Redis 作为缓存服务器使用时，以读操作为主，很少写操作，相应的操作被打断的几率较</p><p>少。不采用悲观锁是为了防止降低性能。</p><h5 id="_2、乐观锁" tabindex="-1"><a class="header-anchor" href="#_2、乐观锁" aria-hidden="true">#</a> 2、乐观锁</h5><p>执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操</p><p>作的干扰，那么本次操作将被放弃。</p><h4 id="_5、redis-中的锁策略" tabindex="-1"><a class="header-anchor" href="#_5、redis-中的锁策略" aria-hidden="true">#</a> 5、Redis 中的锁策略</h4><ul><li><p>Redis 采用了乐观锁策略**（通过watch 操作）**。乐观锁支持读操作，适用于多读少写的情况！</p></li><li><p>在事务中，可以通过<strong>watch 命令来加锁</strong>；使用<strong>UNWATCH 可以取消加锁</strong>；</p></li><li><p>如果在事务之前，执行了WATCH（加锁），那么执行EXEC 命令或DISCARD 命令后，锁对自动释放，即不需</p><p>要再执行UNWATCH 了</p></li></ul><h3 id="_7、redis-cluste集群" tabindex="-1"><a class="header-anchor" href="#_7、redis-cluste集群" aria-hidden="true">#</a> 7、Redis Cluste集群</h3><blockquote><p>什么是集群： Redis 集群实现了对Redis 的水平扩容，即启动N 个redis 节点，将整个数据库分布存储在这N 个节点中，每个节点存储总数据的1/N。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p></blockquote><h4 id="_1、搭建集群环境" tabindex="-1"><a class="header-anchor" href="#_1、搭建集群环境" aria-hidden="true">#</a> 1、搭建集群环境</h4><h5 id="_1、创建目录并修改集群配置文件-redis-conf" tabindex="-1"><a class="header-anchor" href="#_1、创建目录并修改集群配置文件-redis-conf" aria-hidden="true">#</a> 1、创建目录并修改集群配置文件（redis.conf）</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>mkdir cluster<span class="token operator">-</span>test
cd cluster<span class="token operator">-</span>test
mkdir <span class="token number">7000</span> <span class="token number">7001</span> <span class="token number">7002</span> <span class="token number">7003</span> <span class="token number">7004</span> <span class="token number">7005</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>port <span class="token number">7000</span>
<span class="token comment">//开启集群模式</span>
cluster<span class="token operator">-</span>enabled yes
cluster<span class="token operator">-</span>config<span class="token operator">-</span>file nodes<span class="token punctuation">.</span>conf
cluster<span class="token operator">-</span>node<span class="token operator">-</span>timeout <span class="token number">5000</span>
appendonly yes

<span class="token comment">//依次修改6个配置文件</span>
cp <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7000</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7000</span><span class="token operator">/</span>
<span class="token operator">:</span><span class="token operator">%</span>s<span class="token operator">/</span><span class="token number">7000</span><span class="token operator">/</span><span class="token number">7001</span><span class="token operator">/</span>g      替换
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2、启动节点" tabindex="-1"><a class="header-anchor" href="#_2、启动节点" aria-hidden="true">#</a> 2、启动节点</h5><p>把安装Redis目录下的src复制到redis_cluster下，方便启动服务</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//进入安装目录下 cd /root/tool/redis-5.0.8/（我的为例）</span>
cp <span class="token operator">-</span>r <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>redis_cluster
    
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7000</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7001</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7002</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7003</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7004</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server <span class="token punctuation">.</span><span class="token operator">/</span><span class="token number">7005</span><span class="token operator">/</span>redis<span class="token punctuation">.</span>conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200407231906916.png" alt="image-20200407231906916" loading="lazy"></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ps <span class="token operator">-</span>ef <span class="token operator">|</span>grep <span class="token operator">-</span>i redis          <span class="token comment">//查看进程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_3、创建集群" tabindex="-1"><a class="header-anchor" href="#_3、创建集群" aria-hidden="true">#</a> 3、创建集群</h5><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//redis5之后</span>
<span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">--</span>cluster create <span class="token operator">-</span>a 密码 <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7000</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7001</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7002</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7003</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7004</span> <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">7005</span> <span class="token operator">--</span>cluster<span class="token operator">-</span>replicas <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/yhx1001/PicGo/img/image-20200408194731829.png" alt="image-20200408194731829" loading="lazy"></p><h4 id="_2、集群验证" tabindex="-1"><a class="header-anchor" href="#_2、集群验证" aria-hidden="true">#</a> 2、集群验证</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>./src/redis-cli -p 7000 -a 密码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>127.0.0.1:7000&gt; CLUSTER nodes
b7959193eb80fa0abc8cf9d296d08de76cf47f4d 127.0.0.1:7002@17002 master - 0 1586346968000 3 connected 10923-16383
74dc8b2155478d22d147d86dd052f84824bcc021 127.0.0.1:7001@17001 master - 0 1586346969041 2 connected 5461-10922
26764a2d2dc63b0ba3216de62ac0a171329e6f43 127.0.0.1:7005@17005 slave 1af6831ee1e7f9448fed04fab40b68f30b001b59 0 1586346968033 6 connected
1af6831ee1e7f9448fed04fab40b68f30b001b59 127.0.0.1:7000@17000 myself,master - 0 1586346968000 1 connected 0-5460
6373481e4202f55a6d3a0f46a0da00a395573861 127.0.0.1:7003@17003 slave 74dc8b2155478d22d147d86dd052f84824bcc021 0 1586346968537 4 connected
20c5257ce6ea6a2aa666f283e068e865152c52a6 127.0.0.1:7004@17004 slave b7959193eb80fa0abc8cf9d296d08de76cf47f4d 0 1586346969544 5 connected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3、集群开启与关闭" tabindex="-1"><a class="header-anchor" href="#_3、集群开启与关闭" aria-hidden="true">#</a> 3、集群开启与关闭</h4><h5 id="_1、开启" tabindex="-1"><a class="header-anchor" href="#_1、开启" aria-hidden="true">#</a> 1、开启</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#redisstart.sh     –c 参数实现自动重定向</span>
/usr/local/redis_cluster/src/redis-server ./7000/redis.conf
/usr/local/redis_cluster/src/redis-server ./7001/redis.conf
/usr/local/redis_cluster/src/redis-server ./7002/redis.conf
/usr/local/redis_cluster/src/redis-server ./7003/redis.conf
/usr/local/redis_cluster/src/redis-server ./7004/redis.conf
/usr/local/redis_cluster/src/redis-server ./7005/redis.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>chmod u<span class="token operator">+</span>x redisall<span class="token punctuation">.</span>sh  <span class="token comment">//变成可执行文件</span>
<span class="token punctuation">.</span><span class="token operator">/</span>redisall<span class="token punctuation">.</span>sh          <span class="token comment">//在当前目录下启动</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#startall.sh
/usr/local/redis_cluster/src/redis-cli --cluster create -a 密码 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>chmod u<span class="token operator">+</span>x startall<span class="token punctuation">.</span>sh
<span class="token punctuation">.</span><span class="token operator">/</span>startall<span class="token punctuation">.</span>sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2、关闭" tabindex="-1"><a class="header-anchor" href="#_2、关闭" aria-hidden="true">#</a> 2、关闭</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#shutdown.sh
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7000 -a 密码 shutdown
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7001 -a 密码 shutdown
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7002 -a 密码 shutdown
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7003 -a 密码 shutdown
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7004 -a 密码 shutdown
/usr/local/redis_cluster/src/redis-cli -c -h 127.0.0.1 -p 7005 -a 密码 shutdown
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>chmod u+x shutdown.sh
./shutdown.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4、集群中故障恢复" tabindex="-1"><a class="header-anchor" href="#_4、集群中故障恢复" aria-hidden="true">#</a> 4、集群中故障恢复</h4><p>问题1：如果主节点下线？从节点能否自动升为主节点？</p><blockquote><p>答：<strong>主节点下线，从节点自动升为主节点</strong>。</p></blockquote><p>问题2：主节点恢复后，主从关系会如何？</p><blockquote><p><strong>主节点恢复后，主节点变为从节点！</strong></p></blockquote><p>问题3：如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续?</p><blockquote><p>答：<strong>服务是否继续，可以通过redis.conf 中的cluster-require-full-coverage 参数进行控制。</strong></p></blockquote><blockquote><p>主从都宕掉，意味着有一片数据，会变成真空，没法再访问了！ 如果无法访问的数据，是连续的业务数据，我们需要停止集群，避免缺少此部分数据，造成整个业务的异常。此时可以通过配置cluster-require-full-coverage 为yes. 如果无法访问的数据，是相对独立的，对于其他业务的访问，并不影响，那么可以继续开启集群体提供服务。此时，可以配置cluster-require-full-coverage 为no。</p></blockquote><h4 id="_5、集群的优缺点" tabindex="-1"><a class="header-anchor" href="#_5、集群的优缺点" aria-hidden="true">#</a> 5、集群的优缺点</h4><p><strong>优点：</strong></p><ul><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ul><p><strong>缺点：</strong></p><ul><li>多键操作是不被支持的</li><li>多键的Redis 事务是不被支持的。lua 脚本不被支持。</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁 移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul>`,198);function y(f,x){const a=i("ExternalLinkIcon");return l(),c("div",null,[r,s("blockquote",null,[s("p",null,[d,n("是一个使用"),s("a",u,[n("ANSI C"),e(a)]),n("编写的"),s("a",m,[n("开源"),e(a)]),n("、支持"),s("a",k,[n("网络"),e(a)]),n("、基于"),s("a",v,[n("内存"),e(a)]),n("、可选"),s("a",b,[n("持久性"),e(a)]),n("的[键值对存储数据库]")]),h]),g])}const E=t(o,[["render",y],["__file","get-started.html.vue"]]);export{E as default};
